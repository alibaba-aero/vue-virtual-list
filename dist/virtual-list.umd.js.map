{"version":3,"file":"virtual-list.umd.js","sources":["../node_modules/debounce/index.js","../src/utils/scroll.js","../src/components/list-view.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/wrapper.js"],"sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","export function isScrollable (node) {\n    const scrollRegex = /(auto|scroll)/;\n\n    function getStyle (node, prop) {\n        getComputedStyle(node, null).getPropertyValue(prop);\n    }\n\n    return (\n        scrollRegex.test(getStyle(node, 'overflow')) ||\n        scrollRegex.test(getStyle(node, 'overflow-x')) ||\n        scrollRegex.test(getStyle(node, 'overflow-y'))\n    );\n};\n\nexport function getFirstScrollableParent (node) {\n    const parentNode = node && node.parentNode;\n    if (!parentNode || parentNode === document.body) {\n        return document.body;\n    } else if (isScrollable(parentNode)) {\n        return parentNode;\n    } else {\n        return getFirstScrollableParent(parentNode);\n    }\n};\n","<template>\n    <div\n        class=\"listview\"\n        :class=\"{ ready }\"\n        :style=\"{ height: `${totalHeight}px` }\"\n    >\n        <div\n            v-for=\"view in pool\"\n            class=\"listview__item\"\n            :key=\"view.nr.id\"\n            :style=\"ready ? { transform: `translateY(${view.position}px)` } : null\"\n            :ref=\"`listviewItem`\"\n        >\n            <slot\n                :item=\"view.item\"\n                :index=\"view.nr.index\"\n                :active=\"view.nr.used\"\n            />\n        </div>\n    </div>\n</template>\n\n<script>\nimport { debounce } from 'debounce';\nimport { getFirstScrollableParent } from '../utils/scroll';\n\nlet uid = 0;\n\nexport default {\n    props: {\n        items: {\n            type: Array,\n            default: () => [],\n        },\n        keyField: {\n            type: String,\n            default: 'id',\n        },\n        prerender: {\n            type: Number,\n            default: 0,\n        },\n        itemSize: {\n            type: Number,\n            default: null,\n        },\n        buffer: {\n            type: Number,\n            default: 10,\n        },\n        typeField: {\n            type: String,\n            default: 'type',\n        },\n    },\n    data () {\n        return {\n            scrollableParent: null,\n            totalHeight: 0,\n            ready: false,\n            pool: [],\n            sizeCache: new Map(),\n            views: new Map(),\n            unusedViews: new Map(),\n            averageItemSize: 0,\n            minItemSize: 0,\n            anchorItem: { index: 0, offset: 0 },\n            firstAttachedItem: 0,\n            lastAttachedItem: 0,\n            anchorScrollTop: 0,\n        };\n    },\n    watch: {\n        items () {\n            this.updateVisibleItems(true);\n        },\n    },\n    created () {\n        this.$_scrollDirty = false;\n        this.$_window_width = null;\n        this.debouncedUpdatePositions = debounce(this.updateItemsPosition, 100);\n\n        // In SSR mode, we also prerender the same number of item for the first render\n        // to avoir mismatch between server and client templates\n        if (this.prerender) {\n            this.$_prerender = true;\n            this.updateVisibleItems(false);\n        }\n    },\n    mounted () {\n        this.$_window_width = window.innerWidth;\n        this.init();\n    },\n    beforeDestroy () {\n        this.removeEventListeners();\n    },\n    methods: {\n        getFirstScrollableParent () {\n            return getFirstScrollableParent(this.$el);\n        },\n\n        init () {\n            const scrollableParent = this.getFirstScrollableParent();\n\n            if (scrollableParent !== document.body) {\n                this.scrollableParent = scrollableParent;\n            }\n\n            this.addEventListeners();\n\n            // In SSR mode, render the real number of visible items\n            this.$_prerender = false;\n            this.updateVisibleItems(true);\n            this.ready = true;\n        },\n\n        addEventListeners () {\n            if (!this.scrollableParent) {\n                window.addEventListener('scroll', this.onScroll);\n            } else {\n                this.scrollableParent.addEventListener('scroll', this.onScroll);\n            }\n\n            window.addEventListener('resize', this.onResize);\n        },\n\n        removeEventListeners () {\n            if (!this.scrollableParent) {\n                window.removeEventListener('scroll', this.onScroll);\n            } else {\n                this.scrollableParent.removeEventListener('scroll', this.onScroll);\n            }\n\n            window.removeEventListener('resize', this.onResize);\n        },\n\n        onScroll () {\n            if (!this.$_scrollDirty) {\n                this.$_scrollDirty = true;\n                requestAnimationFrame(() => {\n                    this.$_scrollDirty = false;\n                    const { continuous } = this.updateVisibleItems(false, true);\n                    // It seems sometimes chrome doesn't fire scroll event :/\n                    // When non continous scrolling is ending, we force a refresh\n                    if (!continuous) {\n                        clearTimeout(this.$_refreshTimout);\n                        this.$_refreshTimout = setTimeout(this.handleScroll, 100);\n                    }\n                });\n            }\n        },\n\n        onResize () {\n            if (this.$_window_width !== window.innerWidth) {\n                this.clearSizeCache();\n                if (this.ready) {\n                    this.updateVisibleItems(false);\n                };\n            }\n        },\n\n        clearSizeCache () {\n            this.averageItemSize = null;\n            this.minItemSize = null;\n            this.sizeCache.clear();\n        },\n\n        calculateAnchoredItem (initialAnchor, delta) {\n            const keyField = this.keyField;\n\n            if (delta === 0) {\n                return initialAnchor;\n            } else {\n                delta += initialAnchor.offset;\n                let i = initialAnchor.index;\n\n                if (delta < 0) {\n                    while (delta < 0 && i > 0) {\n                        const key = keyField ? this.items[i - 1][keyField] : this.items[i - 1];\n                        const height = this.sizeCache.get(key) || this.averageItemSize;\n                        delta += height;\n                        i--;\n                    }\n                } else {\n                    while (delta > 0 && i < this.items.length - 1) {\n                        const key = keyField ? this.items[i + 1][keyField] : this.items[i + 1];\n                        const height = this.sizeCache.get(key) || this.averageItemSize;\n                        delta -= height;\n                        i++;\n                    }\n                }\n\n                return {\n                    index: i,\n                    offset: delta,\n                };\n            }\n        },\n\n        async updateVisibleItems (checkItem, checkPositionDiff = false) {\n            const items = this.items;\n            const count = items.length;\n            const itemSize = this.itemSize;\n            const minItemSize = this.minItemSize;\n            const averageItemSize = this.averageItemSize;\n            const buffer = this.buffer;\n            const views = this.views;\n            const unusedViews = this.unusedViews;\n            const keyField = this.keyField;\n            const typeField = this.typeField;\n            const pool = this.pool;\n\n            const prevFirstAttachedItem = this.firstAttachedItem;\n            const prevLastAttachedItem = this.lastAttachedItem;\n\n            if (!count) {\n                this.firstAttachedItem = 0;\n                this.lastAttachedItem = 0;\n                this.totalHeight = 0;\n                return;\n            } else if (this.$_prerender) {\n                this.firstAttachedItem = 0;\n                this.lastAttachedItem = this.prerender;\n                this.totalHeight = null;\n                return;\n            } else if (!itemSize && (!minItemSize || !averageItemSize)) {\n                // render an initial number of items to estimate item size\n                this.lastAttachedItem = this.firstAttachedItem + 20;\n            } else {\n                const scroll = this.getScroll();\n                const delta = scroll.start - this.anchorScrollTop;\n\n                // Skip update if user hasn't scrolled enough\n                if (checkPositionDiff) {\n                    let positionDiff = delta;\n\n                    if (positionDiff < 0) {\n                        positionDiff = -positionDiff;\n                    }\n\n                    if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n                        return {\n                            continuous: true,\n                        };\n                    }\n                }\n\n                if (scroll.start === 0) {\n                    this.anchorItem = { index: 0, offset: 0 };\n                } else {\n                    this.anchorItem = this.calculateAnchoredItem(this.anchorItem, delta);\n                }\n\n                this.anchorScrollTop = scroll.start;\n                const lastScreenItem = this.calculateAnchoredItem(this.anchorItem, scroll.end);\n                this.firstAttachedItem = Math.max(0, this.anchorItem.index - buffer);\n                this.lastAttachedItem = Math.min(this.items.length, lastScreenItem.index + buffer);\n            }\n\n            // Collect unused views\n            const continuous = this.firstAttachedItem <= prevLastAttachedItem && this.lastAttachedItem >= prevFirstAttachedItem;\n\n            if (this.continuous !== continuous) {\n                if (continuous) {\n                    views.clear();\n                    unusedViews.clear();\n                    this.pool.forEach((view) => {\n                        this.unuseView(view);\n                    });\n                }\n                this.continuous = continuous;\n            } else if (continuous) {\n                this.pool.forEach((view) => {\n                    if (view.nr.used) {\n                        // Update view item index\n                        if (checkItem) {\n                            view.nr.index = items.findIndex((item) => {\n                                return this.keyField ? item[keyField] === view.item[keyField] : item === view.item;\n                            });\n                        }\n\n                        // Check if index is still in visible range\n                        if (view.nr.index === -1 || view.nr.index < this.firstAttachedItem || view.nr.index >= this.lastAttachedItem) {\n                            this.unuseView(view);\n                        }\n                    }\n                });\n            }\n\n            // Use or create views\n            const unusedIndex = continuous ? null : new Map();\n\n            let item, type, unusedPool;\n            let v;\n            let view;\n\n            for (let i = this.firstAttachedItem; i < this.lastAttachedItem; i++) {\n                item = items[i];\n                const key = keyField ? item[keyField] : item;\n\n                if (key == null) {\n                    throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n                }\n\n                view = views.get(key);\n\n                // No view assigned to item\n                if (!view) {\n                    type = item[typeField];\n                    unusedPool = unusedViews.get(type);\n\n                    if (continuous) {\n                        // Reuse existing view\n                        if (unusedPool && unusedPool.length) {\n                            view = unusedPool.pop();\n                            view.item = item;\n                            view.nr.used = true;\n                            view.nr.index = i;\n                            view.nr.key = key;\n                            view.nr.type = type;\n                        } else {\n                            view = this.addView(pool, i, item, key, type);\n                        }\n                    } else {\n                        // Use existing view\n                        // We don't care if they are already used\n                        // because we are not in continous scrolling\n                        v = unusedIndex.get(type) || 0;\n                        if (!unusedPool || v >= unusedPool.length) {\n                            view = this.addView(pool, i, item, key, type);\n                            this.unuseView(view, true);\n                            unusedPool = unusedViews.get(type);\n                        }\n                        view = unusedPool[v];\n                        view.item = item;\n                        view.nr.used = true;\n                        view.nr.index = i;\n                        view.nr.key = key;\n                        view.nr.type = type;\n                        unusedIndex.set(type, v + 1);\n                        v++;\n                    }\n                    views.set(key, view);\n                } else {\n                    view.nr.used = true;\n                    view.item = item;\n                }\n            }\n\n            await this.$nextTick();\n            this.measureItems();\n            this.totalHeight = this.calculateTotalHeight();\n            this.fixScrollPosition();\n\n            this.debouncedUpdatePositions();\n        },\n\n        getScroll () {\n            const { $el: el } = this;\n            let scrollState;\n\n            if (!this.scrollableParent) {\n                const bounds = el.getBoundingClientRect();\n                const boundsSize = bounds.height;\n                let start = -bounds.top;\n                let size = window.innerHeight;\n                if (start < 0) {\n                    size += start;\n                    start = 0;\n                }\n\n                if (start + size > boundsSize) {\n                    size = boundsSize - start;\n                }\n\n                scrollState = {\n                    start,\n                    end: start + size,\n                };\n            } else {\n                scrollState = {\n                    start: this.scrollableParent.scrollTop,\n                    end: this.scrollableParent.scrollTop + this.scrollableParent.clientHeight,\n                };\n            }\n\n            return scrollState;\n        },\n\n        calculateTotalHeight () {\n            if (this.itemSize) {\n                return this.itemSize * this.items.length;\n            }\n\n            let height = 0;\n\n            const itemsWithSizeCount = this.sizeCache.size;\n            const itemsWithoutSizeCount = this.items.length - itemsWithSizeCount;\n\n            height += itemsWithoutSizeCount * this.averageItemSize;\n\n            this.sizeCache.forEach((size) => {\n                height += size;\n            });\n\n            return height;\n        },\n\n        unuseView (view, fake = false) {\n            const unusedViews = this.unusedViews;\n            const type = view.nr.type;\n            let unusedPool = unusedViews.get(type);\n            if (!unusedPool) {\n                unusedPool = [];\n                unusedViews.set(type, unusedPool);\n            }\n            unusedPool.push(view);\n            if (!fake) {\n                view.nr.used = false;\n                view.position = -9999;\n                this.views.delete(view.nr.key);\n            }\n        },\n\n        addView (pool, index, item, key, type) {\n            const view = {\n                item,\n                position: 0,\n            };\n\n            const nonReactive = {\n                id: uid++,\n                index,\n                used: true,\n                key,\n                type,\n            };\n\n            Object.defineProperty(view, 'nr', {\n                configurable: false,\n                value: nonReactive,\n            });\n\n            pool.push(view);\n            return view;\n        },\n\n        measureItems () {\n            const poolDomElements = this.$refs.listviewItem;\n            let hasUpdated = false;\n\n            poolDomElements.forEach((poolDomElement, index) => {\n                const view = this.pool[index];\n\n                if (view.nr.used) {\n                    const height = poolDomElement.offsetHeight;\n                    const key = view.nr.key;\n                    if (!this.sizeCache.has(key) || this.sizeCache.get(key) !== height) {\n                        hasUpdated = true;\n                        this.sizeCache.set(key, height);\n                    }\n                }\n            });\n\n            if (hasUpdated) {\n                const sizesCount = this.sizeCache.size;\n                let minItemSize = null;\n                let sizesSum = 0;\n\n                this.sizeCache.forEach((size) => {\n                    minItemSize = minItemSize === null ? size : Math.min(size, minItemSize);\n                    sizesSum += size;\n                });\n\n                const averageItemSize = sizesSum / sizesCount;\n\n                this.minItemSize = minItemSize;\n                this.averageItemSize = averageItemSize;\n            }\n        },\n\n        fixScrollPosition () {\n            let anchorScrollTop = 0;\n\n            for (let i = 0; i < this.anchorItem.index; i++) {\n                const keyField = this.keyField;\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                anchorScrollTop += this.sizeCache.get(key) || this.averageItemSize || 0;\n            }\n\n            anchorScrollTop += this.anchorItem.offset;\n            this.anchorScrollTop = anchorScrollTop;\n        },\n\n        updateItemsPosition () {\n            const keyField = this.keyField;\n\n            // Position all nodes.\n            let curPos = this.anchorScrollTop - this.anchorItem.offset;\n            let i = this.anchorItem.index;\n            while (i > this.firstAttachedItem) {\n                const key = keyField ? this.items[i - 1][keyField] : this.items[i - 1];\n                curPos -= this.sizeCache.get(key) || this.averageItemSize || 0;\n                i--;\n            }\n            while (i < this.firstAttachedItem) {\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                curPos += this.sizeCache.get(key) || this.averageItemSize || 0;\n                i++;\n            }\n\n            for (let i = this.firstAttachedItem; i < this.lastAttachedItem; i++) {\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                const view = this.views.get(key);\n                view.position = curPos;\n                curPos += this.sizeCache.get(key) || this.averageItemSize || 0;\n            }\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.listview {\n    position: relative;\n    overflow: hidden;\n\n    &.ready &__item {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        will-change: transform;\n    }\n}\n</style>\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","import ListView from './components/list-view.vue';\n\nexport function install (Vue) {\n    if (install.installed) return;\n    install.installed = true;\n    Vue.component('ListView', ListView);\n};\n\nconst plugin = {\n    install,\n};\n\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n    GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n    GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n    GlobalVue.use(plugin);\n}\n\n// To allow use as module (npm/webpack/etc.) export component\nexport default ListView;\n"],"names":["isScrollable","node","scrollRegex","getStyle","prop","getComputedStyle","getPropertyValue","test","getFirstScrollableParent","parentNode","document","body","install","Vue","installed","component","ListView","plugin","GlobalVue","window","global","use"],"mappings":"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"}
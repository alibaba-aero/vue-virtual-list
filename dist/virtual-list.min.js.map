{"version":3,"file":"virtual-list.min.js","sources":["../node_modules/debounce/index.js","../src/utils/scroll.js","../src/components/list-view.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/wrapper.js"],"sourcesContent":["/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","export function isScrollable (node) {\n    const scrollRegex = /(auto|scroll)/;\n\n    function getStyle (node, prop) {\n        getComputedStyle(node, null).getPropertyValue(prop);\n    }\n\n    return (\n        scrollRegex.test(getStyle(node, 'overflow')) ||\n        scrollRegex.test(getStyle(node, 'overflow-x')) ||\n        scrollRegex.test(getStyle(node, 'overflow-y'))\n    );\n};\n\nexport function getFirstScrollableParent (node) {\n    const parentNode = node && node.parentNode;\n    if (!parentNode || parentNode === document.body) {\n        return document.body;\n    } else if (isScrollable(parentNode)) {\n        return parentNode;\n    } else {\n        return getFirstScrollableParent(parentNode);\n    }\n};\n","<template>\n    <div\n        class=\"listview\"\n        :class=\"{ ready }\"\n        :style=\"{ height: `${totalHeight}px` }\"\n    >\n        <div\n            v-for=\"view in pool\"\n            class=\"listview__item\"\n            :key=\"view.nr.id\"\n            :style=\"ready ? { transform: `translateY(${view.position}px)` } : null\"\n            :ref=\"`listviewItem`\"\n        >\n            <slot\n                :item=\"view.item\"\n                :index=\"view.nr.index\"\n                :active=\"view.nr.used\"\n            />\n        </div>\n    </div>\n</template>\n\n<script>\nimport { debounce } from 'debounce';\nimport { getFirstScrollableParent } from '../utils/scroll';\n\nlet uid = 0;\n\nexport default {\n    props: {\n        items: {\n            type: Array,\n            default: () => [],\n        },\n        keyField: {\n            type: String,\n            default: 'id',\n        },\n        prerender: {\n            type: Number,\n            default: 0,\n        },\n        itemSize: {\n            type: Number,\n            default: null,\n        },\n        buffer: {\n            type: Number,\n            default: 10,\n        },\n        typeField: {\n            type: String,\n            default: 'type',\n        },\n    },\n    data () {\n        return {\n            scrollableParent: null,\n            totalHeight: 0,\n            ready: false,\n            pool: [],\n            sizeCache: new Map(),\n            views: new Map(),\n            unusedViews: new Map(),\n            averageItemSize: 0,\n            minItemSize: 0,\n            anchorItem: { index: 0, offset: 0 },\n            firstAttachedItem: 0,\n            lastAttachedItem: 0,\n            anchorScrollTop: 0,\n        };\n    },\n    watch: {\n        items () {\n            this.updateVisibleItems(true);\n        },\n    },\n    created () {\n        this.$_scrollDirty = false;\n        this.$_window_width = null;\n        this.debouncedUpdatePositions = debounce(this.updateItemsPosition, 100);\n\n        // In SSR mode, we also prerender the same number of item for the first render\n        // to avoir mismatch between server and client templates\n        if (this.prerender) {\n            this.$_prerender = true;\n            this.updateVisibleItems(false);\n        }\n    },\n    mounted () {\n        this.$_window_width = window.innerWidth;\n        this.init();\n    },\n    beforeDestroy () {\n        this.removeEventListeners();\n    },\n    methods: {\n        getFirstScrollableParent () {\n            return getFirstScrollableParent(this.$el);\n        },\n\n        init () {\n            const scrollableParent = this.getFirstScrollableParent();\n\n            if (scrollableParent !== document.body) {\n                this.scrollableParent = scrollableParent;\n            }\n\n            this.addEventListeners();\n\n            // In SSR mode, render the real number of visible items\n            this.$_prerender = false;\n            this.updateVisibleItems(true);\n            this.ready = true;\n        },\n\n        addEventListeners () {\n            if (!this.scrollableParent) {\n                window.addEventListener('scroll', this.onScroll);\n            } else {\n                this.scrollableParent.addEventListener('scroll', this.onScroll);\n            }\n\n            window.addEventListener('resize', this.onResize);\n        },\n\n        removeEventListeners () {\n            if (!this.scrollableParent) {\n                window.removeEventListener('scroll', this.onScroll);\n            } else {\n                this.scrollableParent.removeEventListener('scroll', this.onScroll);\n            }\n\n            window.removeEventListener('resize', this.onResize);\n        },\n\n        onScroll () {\n            if (!this.$_scrollDirty) {\n                this.$_scrollDirty = true;\n                requestAnimationFrame(() => {\n                    this.$_scrollDirty = false;\n                    const { continuous } = this.updateVisibleItems(false, true);\n                    // It seems sometimes chrome doesn't fire scroll event :/\n                    // When non continous scrolling is ending, we force a refresh\n                    if (!continuous) {\n                        clearTimeout(this.$_refreshTimout);\n                        this.$_refreshTimout = setTimeout(this.handleScroll, 100);\n                    }\n                });\n            }\n        },\n\n        onResize () {\n            if (this.$_window_width !== window.innerWidth) {\n                this.clearSizeCache();\n                if (this.ready) {\n                    this.updateVisibleItems(false);\n                };\n            }\n        },\n\n        clearSizeCache () {\n            this.averageItemSize = null;\n            this.minItemSize = null;\n            this.sizeCache.clear();\n        },\n\n        calculateAnchoredItem (initialAnchor, delta) {\n            const keyField = this.keyField;\n\n            if (delta === 0) {\n                return initialAnchor;\n            } else {\n                delta += initialAnchor.offset;\n                let i = initialAnchor.index;\n\n                if (delta < 0) {\n                    while (delta < 0 && i > 0) {\n                        const key = keyField ? this.items[i - 1][keyField] : this.items[i - 1];\n                        const height = this.sizeCache.get(key) || this.averageItemSize;\n                        delta += height;\n                        i--;\n                    }\n                } else {\n                    while (delta > 0 && i < this.items.length - 1) {\n                        const key = keyField ? this.items[i + 1][keyField] : this.items[i + 1];\n                        const height = this.sizeCache.get(key) || this.averageItemSize;\n                        delta -= height;\n                        i++;\n                    }\n                }\n\n                return {\n                    index: i,\n                    offset: delta,\n                };\n            }\n        },\n\n        async updateVisibleItems (checkItem, checkPositionDiff = false) {\n            const items = this.items;\n            const count = items.length;\n            const itemSize = this.itemSize;\n            const minItemSize = this.minItemSize;\n            const averageItemSize = this.averageItemSize;\n            const buffer = this.buffer;\n            const views = this.views;\n            const unusedViews = this.unusedViews;\n            const keyField = this.keyField;\n            const typeField = this.typeField;\n            const pool = this.pool;\n\n            const prevFirstAttachedItem = this.firstAttachedItem;\n            const prevLastAttachedItem = this.lastAttachedItem;\n\n            if (!count) {\n                this.firstAttachedItem = 0;\n                this.lastAttachedItem = 0;\n                this.totalHeight = 0;\n                return;\n            } else if (this.$_prerender) {\n                this.firstAttachedItem = 0;\n                this.lastAttachedItem = this.prerender;\n                this.totalHeight = null;\n                return;\n            } else if (!itemSize && (!minItemSize || !averageItemSize)) {\n                // render an initial number of items to estimate item size\n                this.lastAttachedItem = this.firstAttachedItem + 20;\n            } else {\n                const scroll = this.getScroll();\n                const delta = scroll.start - this.anchorScrollTop;\n\n                // Skip update if user hasn't scrolled enough\n                if (checkPositionDiff) {\n                    let positionDiff = delta;\n\n                    if (positionDiff < 0) {\n                        positionDiff = -positionDiff;\n                    }\n\n                    if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n                        return {\n                            continuous: true,\n                        };\n                    }\n                }\n\n                if (scroll.start === 0) {\n                    this.anchorItem = { index: 0, offset: 0 };\n                } else {\n                    this.anchorItem = this.calculateAnchoredItem(this.anchorItem, delta);\n                }\n\n                this.anchorScrollTop = scroll.start;\n                const lastScreenItem = this.calculateAnchoredItem(this.anchorItem, scroll.end);\n                this.firstAttachedItem = Math.max(0, this.anchorItem.index - buffer);\n                this.lastAttachedItem = Math.min(this.items.length, lastScreenItem.index + buffer);\n            }\n\n            // Collect unused views\n            const continuous = this.firstAttachedItem <= prevLastAttachedItem && this.lastAttachedItem >= prevFirstAttachedItem;\n\n            if (this.continuous !== continuous) {\n                if (continuous) {\n                    views.clear();\n                    unusedViews.clear();\n                    this.pool.forEach((view) => {\n                        this.unuseView(view);\n                    });\n                }\n                this.continuous = continuous;\n            } else if (continuous) {\n                this.pool.forEach((view) => {\n                    if (view.nr.used) {\n                        // Update view item index\n                        if (checkItem) {\n                            view.nr.index = items.findIndex((item) => {\n                                return this.keyField ? item[keyField] === view.item[keyField] : item === view.item;\n                            });\n                        }\n\n                        // Check if index is still in visible range\n                        if (view.nr.index === -1 || view.nr.index < this.firstAttachedItem || view.nr.index >= this.lastAttachedItem) {\n                            this.unuseView(view);\n                        }\n                    }\n                });\n            }\n\n            // Use or create views\n            const unusedIndex = continuous ? null : new Map();\n\n            let item, type, unusedPool;\n            let v;\n            let view;\n\n            for (let i = this.firstAttachedItem; i < this.lastAttachedItem; i++) {\n                item = items[i];\n                const key = keyField ? item[keyField] : item;\n\n                if (key == null) {\n                    throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n                }\n\n                view = views.get(key);\n\n                // No view assigned to item\n                if (!view) {\n                    type = item[typeField];\n                    unusedPool = unusedViews.get(type);\n\n                    if (continuous) {\n                        // Reuse existing view\n                        if (unusedPool && unusedPool.length) {\n                            view = unusedPool.pop();\n                            view.item = item;\n                            view.nr.used = true;\n                            view.nr.index = i;\n                            view.nr.key = key;\n                            view.nr.type = type;\n                        } else {\n                            view = this.addView(pool, i, item, key, type);\n                        }\n                    } else {\n                        // Use existing view\n                        // We don't care if they are already used\n                        // because we are not in continous scrolling\n                        v = unusedIndex.get(type) || 0;\n                        if (!unusedPool || v >= unusedPool.length) {\n                            view = this.addView(pool, i, item, key, type);\n                            this.unuseView(view, true);\n                            unusedPool = unusedViews.get(type);\n                        }\n                        view = unusedPool[v];\n                        view.item = item;\n                        view.nr.used = true;\n                        view.nr.index = i;\n                        view.nr.key = key;\n                        view.nr.type = type;\n                        unusedIndex.set(type, v + 1);\n                        v++;\n                    }\n                    views.set(key, view);\n                } else {\n                    view.nr.used = true;\n                    view.item = item;\n                }\n            }\n\n            await this.$nextTick();\n            this.measureItems();\n            this.totalHeight = this.calculateTotalHeight();\n            this.fixScrollPosition();\n\n            this.debouncedUpdatePositions();\n        },\n\n        getScroll () {\n            const { $el: el } = this;\n            let scrollState;\n\n            if (!this.scrollableParent) {\n                const bounds = el.getBoundingClientRect();\n                const boundsSize = bounds.height;\n                let start = -bounds.top;\n                let size = window.innerHeight;\n                if (start < 0) {\n                    size += start;\n                    start = 0;\n                }\n\n                if (start + size > boundsSize) {\n                    size = boundsSize - start;\n                }\n\n                scrollState = {\n                    start,\n                    end: start + size,\n                };\n            } else {\n                scrollState = {\n                    start: this.scrollableParent.scrollTop,\n                    end: this.scrollableParent.scrollTop + this.scrollableParent.clientHeight,\n                };\n            }\n\n            return scrollState;\n        },\n\n        calculateTotalHeight () {\n            if (this.itemSize) {\n                return this.itemSize * this.items.length;\n            }\n\n            let height = 0;\n\n            const itemsWithSizeCount = this.sizeCache.size;\n            const itemsWithoutSizeCount = this.items.length - itemsWithSizeCount;\n\n            height += itemsWithoutSizeCount * this.averageItemSize;\n\n            this.sizeCache.forEach((size) => {\n                height += size;\n            });\n\n            return height;\n        },\n\n        unuseView (view, fake = false) {\n            const unusedViews = this.unusedViews;\n            const type = view.nr.type;\n            let unusedPool = unusedViews.get(type);\n            if (!unusedPool) {\n                unusedPool = [];\n                unusedViews.set(type, unusedPool);\n            }\n            unusedPool.push(view);\n            if (!fake) {\n                view.nr.used = false;\n                view.position = -9999;\n                this.views.delete(view.nr.key);\n            }\n        },\n\n        addView (pool, index, item, key, type) {\n            const view = {\n                item,\n                position: 0,\n            };\n\n            const nonReactive = {\n                id: uid++,\n                index,\n                used: true,\n                key,\n                type,\n            };\n\n            Object.defineProperty(view, 'nr', {\n                configurable: false,\n                value: nonReactive,\n            });\n\n            pool.push(view);\n            return view;\n        },\n\n        measureItems () {\n            const poolDomElements = this.$refs.listviewItem;\n            let hasUpdated = false;\n\n            poolDomElements.forEach((poolDomElement, index) => {\n                const view = this.pool[index];\n\n                if (view.nr.used) {\n                    const height = poolDomElement.offsetHeight;\n                    const key = view.nr.key;\n                    if (!this.sizeCache.has(key) || this.sizeCache.get(key) !== height) {\n                        hasUpdated = true;\n                        this.sizeCache.set(key, height);\n                    }\n                }\n            });\n\n            if (hasUpdated) {\n                const sizesCount = this.sizeCache.size;\n                let minItemSize = null;\n                let sizesSum = 0;\n\n                this.sizeCache.forEach((size) => {\n                    minItemSize = minItemSize === null ? size : Math.min(size, minItemSize);\n                    sizesSum += size;\n                });\n\n                const averageItemSize = sizesSum / sizesCount;\n\n                this.minItemSize = minItemSize;\n                this.averageItemSize = averageItemSize;\n            }\n        },\n\n        fixScrollPosition () {\n            let anchorScrollTop = 0;\n\n            for (let i = 0; i < this.anchorItem.index; i++) {\n                const keyField = this.keyField;\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                anchorScrollTop += this.sizeCache.get(key) || this.averageItemSize || 0;\n            }\n\n            anchorScrollTop += this.anchorItem.offset;\n            this.anchorScrollTop = anchorScrollTop;\n        },\n\n        updateItemsPosition () {\n            const keyField = this.keyField;\n\n            // Position all nodes.\n            let curPos = this.anchorScrollTop - this.anchorItem.offset;\n            let i = this.anchorItem.index;\n            while (i > this.firstAttachedItem) {\n                const key = keyField ? this.items[i - 1][keyField] : this.items[i - 1];\n                curPos -= this.sizeCache.get(key) || this.averageItemSize || 0;\n                i--;\n            }\n            while (i < this.firstAttachedItem) {\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                curPos += this.sizeCache.get(key) || this.averageItemSize || 0;\n                i++;\n            }\n\n            for (let i = this.firstAttachedItem; i < this.lastAttachedItem; i++) {\n                const key = keyField ? this.items[i][keyField] : this.items[i];\n                const view = this.views.get(key);\n                view.position = curPos;\n                curPos += this.sizeCache.get(key) || this.averageItemSize || 0;\n            }\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.listview {\n    position: relative;\n    overflow: hidden;\n\n    &.ready &__item {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        will-change: transform;\n    }\n}\n</style>\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","import ListView from './components/list-view.vue';\n\nexport function install (Vue) {\n    if (install.installed) return;\n    install.installed = true;\n    Vue.component('ListView', ListView);\n};\n\nconst plugin = {\n    install,\n};\n\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n    GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n    GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n    GlobalVue.use(plugin);\n}\n\n// To allow use as module (npm/webpack/etc.) export component\nexport default ListView;\n"],"names":["debounce","func","wait","immediate","timeout","args","context","timestamp","result","later","last","Date","now","setTimeout","apply","debounced","this","arguments","callNow","clear","clearTimeout","flush","getFirstScrollableParent","node","parentNode","document","body","scrollRegex","getStyle","prop","getComputedStyle","getPropertyValue","test","isScrollable","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","hook","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","install","Vue","installed","component","ListView","plugin","GlobalVue","window","global","use"],"mappings":"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"}